(fn [state time-left]
  (def ^:private orientations [:n :s :e :w])

  (defn get-arena-dimensions
    "returns the dimensions of a given arena (NOTE: NOT 0 indexed)"
    {:added "1.0"
     :defined-in "wombats.arena.utils"}
    [arena]
    (let [x ((comp count first) arena)
          y (count arena)]
      [x y]))

  (defn get-arena-dimensions-zero-based
    "returns the dimensions of a given arena"
    {:added "1.0"}
    [arena]
    (map dec (get-arena-dimensions arena)))

  (defn get-in-arena
    "pulls the cell contents out of an arena at given coords"
    {:added "1.0"}
    [[x y] arena]
    (get-in arena [y x]))

  (defn modify-orientation
    "Return a new orientation based off a provided orientation and the direction
  you want to turn"
    {:added "1.0"
     :defined "wombats.game.utils"}
    [current-orientation modifier]
    (let [current-idx (.indexOf orientations current-orientation)]
      (if (not= current-idx -1)
        (condp = modifier
          :right (get orientations (mod (inc current-idx) 4))
          :left (get orientations (mod (dec current-idx) 4))
          :about-face (get orientations (mod (+ 2 current-idx) 4))
          current-orientation)
        current-orientation)))

  (defn get-move-coords
    "Gets the updated coords for moving.

  :Note wrapping not assumed."
    {:added "1.0"}
    [[x y] orientation]
    (case orientation
      :n [x (dec y)]
      :e [(inc x) y]
      :s [x (inc y)]
      :w [(dec x) y]))

  (defn get-move-frontier
    "Returns the coords from the move command"
    {:added "1.0"}
    ([coords orientation dimensions]
     (get-move-frontier coords orientation dimensions false))
    ([[x y] orientation [max-x max-y] wrap?]
     (let [new-coords (get-move-coords [x y] orientation)
           [new-x new-y] new-coords]
       (if wrap?
         (case orientation
           (:n :s) [new-x (mod new-y max-y)]
           (:e :w) [(mod new-x max-x) new-y])
         (case orientation
           :n (if (< new-y 0) nil new-coords)
           :w (if (< new-x 0) nil new-coords)
           :e (if (> new-x max-x) nil new-coords)
           :s (if (> new-y max-y) nil new-coords))))))

  (defn calculate-frontier
    "Caclulates the new frontier set based off of the provided frontier."
    {:added "1.0"}
    ([frontier arena-dimensions]
     (calculate-frontier frontier arena-dimensions false))
    ([{:keys [orientation coords weight cmd-sequence]} arena-dimensions wrap?]
     (let [frontier-orientations
           (map (fn [next-direction]
                  {:orientation (modify-orientation orientation next-direction)
                   :coords coords
                   :weight (inc weight)
                   :cmd-sequence (conj cmd-sequence {:action :turn
                                                     :metadata {:direction next-direction}})})
                (if (= weight 0)
                  [:right :left :about-face]
                  [:right :left]))

           frontier-move
           {:orientation orientation
            :coords (get-move-frontier coords orientation arena-dimensions wrap?)
            :weight (inc weight)
            :cmd-sequence (conj cmd-sequence {:action :move})}]
       (conj frontier-orientations frontier-move))))

  (defn can-safely-occupy-space?
    "Predicate used to determine what cells can pass as frontiers"
    {:added "1.0"}
    [cell]
    (not (contains? #{"wood-barrier" "steel-barrier" "fog"}
                    (get-in cell [:contents :type]))))

  (defn filter-frontier
    "Filters all the possible frontiers, returning only explore-able frontiers"
    {:added "1.0"}
    [frontier arena explored]
    (filter (fn [{coords :coords}]
              (if (nil? coords)
                false
                (let [cell (get-in-arena coords arena)
                      uuid (get-in cell [:contents :uuid])]
                  (and (nil? (get explored uuid))
                       (can-safely-occupy-space? cell))))) frontier))

  (defn add-to-sorted-arena
    "Adds a frontier node to the sorted arena"
    {:added "1.0"}
    [sorted-arena
     {{type :type
       uuid :uuid} :contents}
     {weight :weight
      coords :coords
      cmd-sequence :cmd-sequence}]
    (let [formatted-frontier {:weight weight
                              :uuid uuid
                              :coords coords
                              :cmd-sequence cmd-sequence}]
      (update-in sorted-arena
                 [weight (keyword type)]
                 (fn [coll]
                   (if (not (nil? coll))
                     (conj coll formatted-frontier)
                     [formatted-frontier])))))

  (defn to-global-coords
    "Converts local coordinates passed by the partially occluded arena
  to their corresponding global coordinates"
    {:added "1.0"}
    [{[origin-x origin-y] :local-coords
      [global-x global-y] :global-coords
      [dim-x dim-y] :global-dimensions}]
    (fn [[target-x target-y]]
      (let [delta-x (- target-x origin-x)
            delta-y (- target-y origin-y)
            new-x (mod (+ global-x delta-x) dim-x)
            new-y (mod (+ global-y delta-y) dim-y)]
        [new-x new-y])))

  (defn sort-arena-by-distance-then-type
    "sorts an arena by distance then type"
    {:added "1.0"}
    [{:keys [arena local-coords] :as enriched-state}]
    (let [arena-dimensions (get-arena-dimensions-zero-based arena)
          update-global-coords-fn (to-global-coords enriched-state)
          {{orientation-str :orientation
            uuid :uuid} :contents} (get-in-arena local-coords arena)
          orientation (keyword orientation-str)]
      (loop [frontier [{:coords local-coords
                        :orientation orientation
                        :uuid uuid
                        :weight 0
                        :cmd-sequence []}]
             explored {}
             sorted-arena []]
        (if (empty? frontier)
          (assoc enriched-state :sorted-arena sorted-arena)

          (let [frontier-node (first frontier)
                cell (get-in-arena (:coords frontier-node) arena)
                next-frontier (calculate-frontier frontier-node arena-dimensions)
                filtered-frontier (filter-frontier next-frontier arena explored)]
            (recur (vec (concat (rest frontier) filtered-frontier))
                   (merge explored {(get-in cell [:contents :uuid]) true})
                   (add-to-sorted-arena sorted-arena
                                        cell
                                        frontier-node
                                        #_(update frontier-node
                                                :coords
                                                update-global-coords-fn))))))))

  (defn remove-self
    [uuid]
    (fn [{:keys [wombat] :as weight-map}]
      (if wombat
        (let [filtered-list (vec (filter #(not= uuid (:uuid %)) wombat))]
          (if (empty? filtered-list)
            (dissoc weight-map :wombat)
            (assoc weight-map :wombat filtered-list)))
        weight-map)))

  (defn remove-self-from-sorted-arena
    "removes current user from the sorted arena"
    {:added "1.0"}
    [{:keys [local-coords arena my-uuid] :as enriched-state}]
    (update-in
     enriched-state
     [:sorted-arena]
     (fn [sorted-arena]
       (-> sorted-arena
           (update 0 (remove-self my-uuid))
           (update 1 (remove-self my-uuid))))))

  (defn track-able-cell?
    [{{type :type} :contents}]
    (not (contains? #{"fog"} type)))

  (defn update-global-view
    "updates what your bot has seen historically"
    {:added "1.0"}
    [{:keys [global-arena arena my-uuid] :as enriched-state}]
    (let [update-global-coords-fn (to-global-coords enriched-state)
          current-global-arena (if global-arena
                                 global-arena
                                 (vec (repeat 10 (vec (repeat 10 nil)))))]

      (assoc enriched-state :global-arena
             (:y-global-arena
              (reduce
               (fn [{:keys [y-idx y-global-arena] :as acc} row]
                 {:y-idx (inc y-idx)
                  :y-global-arena
                  (:x-global-arena
                   (reduce
                    (fn [{:keys [x-idx x-global-arena]} cell]
                      {:x-idx (inc x-idx)
                       :x-global-arena (if (track-able-cell? cell)
                                         (assoc-in x-global-arena
                                                   (update-global-coords-fn
                                                    (reverse [x-idx y-idx]))
                                                   cell)
                                         x-global-arena)})
                    {:x-idx 0
                     :x-global-arena y-global-arena} row))})
               {:y-idx 0
                :y-global-arena current-global-arena} arena)))))

  (defn add-my-uuid
    [{:keys [local-coords arena] :as enriched-state}]
    (let [self (get-in-arena local-coords arena)]
      (assoc enriched-state :my-uuid (get-in self [:contents :uuid]))))

  (defn add-closest-food
    [{:keys [sorted-arena] :as enriched-state}]
    (assoc enriched-state
           :closest-food
           (reduce (fn [food weight-map]
                     (if food
                       food
                       (if (:food weight-map)
                         (first (:food weight-map))
                         nil)))
                   nil
                   sorted-arena)))

  (defn choose-command
    [{:keys [closest-food] :as enriched-state}]

    (let [action-seq (or (:cmd-sequence closest-food) [])
          action (first action-seq)]

      (merge enriched-state
             {:command action
              :remaining-action-seq (vec (rest action-seq))})))

  (defn format-response
    [{:keys [command
             global-arena
             remaining-action-seq
             frame-number] :as enriched-state}]

    {:command command
     :state {:global-arena global-arena
             :remaining-action-seq remaining-action-seq
             :frame-number frame-number
             :arena (:arena enriched-state)}})

  (defn inc-frame-number
    [enriched-state {frame-number :frame-number}]
    (assoc enriched-state :frame-number (if frame-number (inc frame-number) 0)))

  (defn enrich-state
    "Adds additional information to the given state used to improve
   the decision-making process"
    {:added "1.0"}
    [{:keys [arena local-coords saved-state] :as state}]
    (-> state
        (inc-frame-number saved-state)
        (add-my-uuid)
        (sort-arena-by-distance-then-type)
        (remove-self-from-sorted-arena)
        #_(update-global-view)))

  (defn main-fn
    [state time-left]
    (-> (enrich-state state)
        (add-closest-food)
        (choose-command)
        (format-response)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;;
  ;; Local Bot Testing
  ;;
  ;; Evaluate each expresion with C-x C-e and then evaluate the
  ;; following to test algorithms
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  (def sample-arena
    [[{:contents {:type "fog"}}
      {:contents {:type "fog"}}
      {:contents {:type "fog"}}
      {:contents {:type "fog"}}
      {:contents {:type "fog"}}
      {:contents {:type "fog"}}
      {:contents {:type "fog"}}]
     [{:contents
       {:type "wood-barrier",
        :hp 20,
        :uuid "174cb9d2-5634-48fb-9e9d-1a256cc3ad04",
        :deterioration-level "low"},
       :meta []}
      {:contents
       {:type "wood-barrier",
        :hp 20,
        :uuid "ba4cacd8-438f-41ab-8978-948281157691",
        :deterioration-level "low"},
       :meta []}
      {:contents
       {:type "wood-barrier",
        :hp 20,
        :uuid "11fefbb1-cd48-4bf9-9b11-0df1ed51b1c8",
        :deterioration-level "low"},
       :meta []}
      {:contents
       {:type "wood-barrier",
        :hp 20,
        :uuid "2dd14184-1bdf-421d-9bdf-3914df66dbe6",
        :deterioration-level "low"},
       :meta []}
      {:contents
       {:type "wood-barrier",
        :hp 20,
        :uuid "70a4ee76-061c-4c47-8a0a-58b2cd4ef25c",
        :deterioration-level "low"},
       :meta []}
      {:contents
       {:type "wood-barrier",
        :hp 20,
        :uuid "111e951e-9950-43eb-9981-5a1a9b44c1d4",
        :deterioration-level "low"},
       :meta []}
      {:contents
       {:type "wood-barrier",
        :hp 20,
        :uuid "4fb7a428-e3d8-4b81-9e49-9f084441b953",
        :deterioration-level "low"},
       :meta []}]
     [{:contents
       {:type "food", :uuid "d13b18eb-6c27-44a1-b88b-7e9b4d0b022a"},
       :meta []}
      {:contents
       {:type "open", :uuid "32556f3e-4c66-4645-9b20-71932faaf29f"},
       :meta []}
      {:contents
       {:type "open", :uuid "d1b70537-8614-4cc2-881d-cded36ecae17"},
       :meta []}
      {:contents
       {:type "food", :uuid "a3a8a883-6f0a-4b4e-980d-8fbf5355029e"},
       :meta []}
      {:contents
       {:type "open", :uuid "ad517c6c-edc4-4a28-903c-d81818b4572b"},
       :meta []}
      {:contents
       {:type "open", :uuid "124b471e-722c-471c-9771-8a35cf68be28"},
       :meta []}
      {:contents
       {:type "open", :uuid "b8ec04d4-7855-44fa-b600-eeba75b9f3be"},
       :meta []}]
     [{:contents
       {:type "open", :uuid "c8d35c13-e34a-4aa5-b8b1-62f90a4cf704"},
       :meta []}
      {:contents
       {:type "open", :uuid "32556f3e-4c66-4645-9b20-71932faaf29f"},
       :meta []}
      {:contents
       {:type "open", :uuid "d1b70537-8614-4cc2-881d-cded36ecae17"},
       :meta []}
      {:contents
       {:type "wombat",
        :uuid "3f7f33fb-d16d-4b0b-a948-657bf864e0fa",
        :color "gray",
        :hp 100,
        :orientation "e",
        :deterioration-level "low"},
       :meta []}
      {:contents
       {:type "open", :uuid "ad517c6c-edc4-4a28-903c-d81818b4572b"},
       :meta []}
      {:contents
       {:type "poison", :uuid "e5e2937a-badd-440c-bee3-c9ef65818d97"},
       :meta []}
      {:contents
       {:type "open", :uuid "b8ec04d4-7855-44fa-b600-eeba75b9f3be"},
       :meta []}]
     [{:contents
       {:type "open", :uuid "c8d35c13-e34a-4aa5-b8b1-62f90a4cf704"},
       :meta []}
      {:contents
       {:type "open", :uuid "32556f3e-4c66-4645-9b20-71932faaf29f"},
       :meta []}
      {:contents
       {:type "open", :uuid "d1b70537-8614-4cc2-881d-cded36ecae17"},
       :meta []}
      {:contents
       {:type "open", :uuid "19817042-e591-488a-ae91-8b5c993d87ec"},
       :meta []}
      {:contents
       {:type "poison", :uuid "bffe627e-f7c3-4ea2-9762-fa5ac14a82ad"},
       :meta []}
      {:contents
       {:type "open", :uuid "124b471e-722c-471c-9771-8a35cf68be28"},
       :meta []}
      {:contents
       {:type "open", :uuid "b8ec04d4-7855-44fa-b600-eeba75b9f3be"},
       :meta []}]
     [{:contents
       {:type "open", :uuid "c8d35c13-e34a-4aa5-b8b1-62f90a4cf704"},
       :meta []}
      {:contents
       {:type "open", :uuid "32556f3e-4c66-4645-9b20-71932faaf29f"},
       :meta []}
      {:contents
       {:type "open", :uuid "d1b70537-8614-4cc2-881d-cded36ecae17"},
       :meta []}
      {:contents
       {:type "open", :uuid "19817042-e591-488a-ae91-8b5c993d87ec"},
       :meta []}
      {:contents
       {:type "open", :uuid "ad517c6c-edc4-4a28-903c-d81818b4572b"},
       :meta []}
      {:contents
       {:type "open", :uuid "124b471e-722c-471c-9771-8a35cf68be28"},
       :meta []}
      {:contents
       {:type "open", :uuid "b8ec04d4-7855-44fa-b600-eeba75b9f3be"},
       :meta []}]
     [{:contents
       {:type "open", :uuid "c8d35c13-e34a-4aa5-b8b1-62f90a4cf704"},
       :meta []}
      {:contents
       {:type "open", :uuid "32556f3e-4c66-4645-9b20-71932faaf29f"},
       :meta []}
      {:contents
       {:type "open", :uuid "d1b70537-8614-4cc2-881d-cded36ecae17"},
       :meta []}
      {:contents
       {:type "open", :uuid "19817042-e591-488a-ae91-8b5c993d87ec"},
       :meta []}
      {:contents
       {:type "open", :uuid "ad517c6c-edc4-4a28-903c-d81818b4572b"},
       :meta []}
      {:contents
       {:type "open", :uuid "124b471e-722c-471c-9771-8a35cf68be28"},
       :meta []}
      {:contents
       {:type "open", :uuid "b8ec04d4-7855-44fa-b600-eeba75b9f3be"},
       :meta []}]])

  (defn- benchmark
    "Benchmarks fn for testing algorithms"
    {:added "1.0"}
    [my-function]
    (time (my-function))
    :done)

  (def ^:private sample-state
    {:local-coords [3 3]
     :global-coords [2 1]
     :global-dimensions [11 11]
     :arena sample-arena
     :saved-state {}})

  ;; Test the sort algorithm
  #_(clojure.pprint/pprint
   (sort-arena-by-distance-then-type sample-state))
  #_(benchmark #(sort-arena-by-distance-then-type sample-state))

  ;; Test state enrichment
  #_(clojure.pprint/pprint
   (main-fn sample-state (fn [])))
  #_(benchmark #(main-fn sample-state (fn [])))
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;; End local Bot Testing
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  ;; Main function call
  (main-fn state time-left))
